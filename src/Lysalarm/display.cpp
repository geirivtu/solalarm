 /*! \file display.cpp
 *
 *  \brief Driver for 7-segment led display, controlled by an 7-seg driver 
 *  \author Geir Turtum
 *  \date   06.mars.2014
 */


#include "arduino.h"

#include "display.h"

/* Ground pins. Pull low to light up number */
#define DIGIT_0 A0
#define DIGIT_1 A1
#define DIGIT_2 A2
#define DIGIT_3 A3


/*  DISPLAY_STATE_MACHINE  */

/* States */

enum state_t {
  S_ON,
  S_OFF,
  S_MIN_BLINK,
  S_HOUR_BLINK,
} 
State = S_ON;

/* States END */

/* State variable  */
boolean Hide = 0; /* Used for blinking the digits */

/* Pins used for writing numbers to segment bcd driver  */
int pin_array_bcd[] = {
  2, 3, 4, 5};
int pin_array_bcd_len = 4;

/* index 0 is digit 0(starting from the right) on the display */
uint8_t disp_number[] = {
  0, 0, 0, 0};

/* State variable END */

/* Initialize pins for display */
void disp_init(){
  int i;
  for(i =0; i<pin_array_bcd_len; i=i+1){
    pinMode(pin_array_bcd[i], OUTPUT); 
    digitalWrite(  pin_array_bcd[i], LOW);
  }  

  pinMode(DIGIT_0, OUTPUT); //GND connections
  pinMode(DIGIT_1, OUTPUT); //GND connections
  pinMode(DIGIT_2, OUTPUT); //GND connections
  pinMode(DIGIT_3, OUTPUT); //GND connections

  /* A0 for digit 0, A1 for digit 1 */
  digitalWrite(DIGIT_0, HIGH); //HIGH = DISPLAY OFF, LOW = DISPLAY ON, 
  digitalWrite(DIGIT_1, HIGH);
  digitalWrite(DIGIT_2, HIGH); //HIGH = DISPLAY OFF, LOW = DISPLAY ON, 
  digitalWrite(DIGIT_3, HIGH);
}


/* Handles displaying of given digit. digit = [0..3] */
void disp_num(int digit){
//TODO simplify function by writing to port instead of pin
  digitalWrite(pin_array_bcd[0], LOW);
  digitalWrite(pin_array_bcd[1], LOW);
  digitalWrite(pin_array_bcd[2], LOW);
  digitalWrite(pin_array_bcd[3], LOW);

  switch(disp_number[digit]){
  case 0:
    break; 

  case 1:
    digitalWrite(pin_array_bcd[0], HIGH);
    break;

  case 2:
    digitalWrite(pin_array_bcd[1], HIGH);
    break;

  case 3:
    digitalWrite(pin_array_bcd[0], HIGH);
    digitalWrite(pin_array_bcd[1], HIGH);     
    break;

  case 4:
    digitalWrite(pin_array_bcd[2], HIGH);
    break;

  case 5:
    digitalWrite(pin_array_bcd[0], HIGH);
    digitalWrite(pin_array_bcd[2], HIGH);
    break;

  case 6:
    digitalWrite(pin_array_bcd[1], HIGH);
    digitalWrite(pin_array_bcd[2], HIGH);
    break;

  case 7:
    digitalWrite(pin_array_bcd[0], HIGH);
    digitalWrite(pin_array_bcd[1], HIGH);
    digitalWrite(pin_array_bcd[2], HIGH);
    break;

  case 8:
    digitalWrite(pin_array_bcd[3], HIGH);
    break;

  case 9:
    digitalWrite(pin_array_bcd[0], HIGH);
    digitalWrite(pin_array_bcd[3], HIGH);
    break;  

  default:
    //Do nothing

    break;


  }  
}  

/* The time to be displayed */
void disp_write(int hour, int minute){
  disp_number[0] = (int)(hour/10);
  disp_number[1] = hour - disp_number[0]*10;

  disp_number[2] = (int)(minute/10);
  disp_number[3] = minute - disp_number[2]*10;
}

void disp_on(){
  switch(State){
  case S_ON:

    break;

  case S_OFF:

    State = S_ON;
    break;

  case S_MIN_BLINK:
    State = S_ON;
    break;

  case S_HOUR_BLINK:
    State = S_ON;
    break;

  }
}

void disp_off(){
  switch(State){
  case S_ON:
    State = S_OFF;
    break;

  case S_OFF:

    break;

  case S_MIN_BLINK:

    State = S_OFF;
    break;

  case S_HOUR_BLINK:
    State = S_OFF;
    break;

  }
}


void disp_min_blink(){
  switch(State){
  case S_ON:
    State = S_MIN_BLINK;
    break;

  case S_OFF:
    State = S_MIN_BLINK;
    break;

  case S_MIN_BLINK:

    break;

  case S_HOUR_BLINK:
    State = S_MIN_BLINK;
    break;

  }

}

void disp_hour_blink(){
  switch(State){
  case S_ON:
    State = S_HOUR_BLINK;
    break;

  case S_OFF:
    State = S_HOUR_BLINK;
    break;

  case S_MIN_BLINK:
    State = S_HOUR_BLINK;
    break;

  case S_HOUR_BLINK:

    break;

  }
}


/* Interrupt generated by the scheduler every few ms. 
 * Handles the multiplexing of the display
 */
void disp_digit_int(){

  /* Decides which digit to display */
  static uint8_t segment_nr = 0;
  if(segment_nr > 3) segment_nr = 0;

  /* Turn off display by setting GND high  */
  digitalWrite(  DIGIT_0, HIGH); 
  digitalWrite(  DIGIT_1, HIGH); 
  digitalWrite(  DIGIT_2, HIGH); 
  digitalWrite(  DIGIT_3, HIGH); 

  switch(State){
  case S_ON:
    switch(segment_nr){
    case 0:
      digitalWrite(  DIGIT_0, LOW);
      break;

    case 1:
      digitalWrite(  DIGIT_1, LOW);
      break;

    case 2:
      digitalWrite(  DIGIT_2, LOW);
      break;

    case 3:
      digitalWrite(  DIGIT_3, LOW);
      break;  
    }

    disp_num(segment_nr);


    break;



  case S_OFF:
    /* Do nothing, display allready off */

    break;

  case S_MIN_BLINK:
    switch(segment_nr){
    case 0:
      digitalWrite(  DIGIT_0, LOW);
      break;

    case 1:
      digitalWrite(  DIGIT_1, LOW);
      break;

    case 2:
      /* Only set min digits low */
      if(Hide){
        digitalWrite(  DIGIT_2, LOW);
      }
      break;

    case 3:
      /* Only set min digits low */
      if(Hide){
        digitalWrite(  DIGIT_3, LOW);
      }
      break;  
    }

    disp_num(segment_nr);
    break;

  case S_HOUR_BLINK:
    switch(segment_nr){
    case 0:
      /* Only set hour digits low */
      if(Hide){
        digitalWrite(  DIGIT_0, LOW);
      } 
      break;

    case 1:
      /* Only set hour digits low */
      if(Hide){
        digitalWrite(  DIGIT_1, LOW);
      } 
      break;

    case 2:
      digitalWrite(  DIGIT_2, LOW);
      break;

    case 3:
      digitalWrite(  DIGIT_3, LOW);
      break;  
    }

    disp_num(segment_nr);
    break;

  }

  segment_nr++;  

}


/* Interrupt generated by the scheduler. Sets the blink rate for the display */
void disp_blink_int(){
  static uint8_t counter=0;
  
  if(counter==3){
   Hide = 0; //Hides digit
   counter = 0; 
  }else{
    Hide = 1; //Displays digit
   counter++;
  }
  
  
  

}
















